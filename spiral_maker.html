<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>p5.js PiP Animation Editor</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        body {
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            margin: 0;
            padding: 20px;
            background: #1a1a1a;
            color: #ffffff;
            min-height: 100vh;
        }
        
        .editor-panel {
            display: flex;
            flex-direction: column;
            margin-right: 340px; /* Make space for fixed preview panel */
        }
        
        .controls {
            margin-bottom: 15px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .export-controls {
            margin-bottom: 15px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        .animation-controls {
            margin-bottom: 15px;
            display: flex;
            gap: 20px;
            align-items: center;
            background: #2d2d2d;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 10px 15px;
        }
        
        .control-group {
            align-items: center;
            gap: 8px;
        }
        
        .control-group label {
            font-size: 12px;
            color: #ccc;
        }
        
        .control-group input {
            background: #1a1a1a;
            border: 1px solid #555;
            border-radius: 3px;
            color: #fff;
            padding: 4px 8px;
            width: 60px;
            font-size: 12px;
            font-family: inherit;
        }
        
        .control-group input:focus {
            outline: none;
            border-color: #0066cc;
        }
        
        button {
            background: #0066cc;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-family: inherit;
            transition: background 0.2s;
        }
        
        button:hover {
            background: #0052a3;
        }
        
        button:disabled {
            background: #555;
            cursor: not-allowed;
        }
        
        textarea {
            flex: 1;
            background: #2d2d2d;
            color: #ffffff;
            border: 1px solid #555;
            padding: 15px;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
            font-size: 14px;
            line-height: 1.4;
            border-radius: 4px;
            resize: vertical;
            min-height: 500px;
            tab-size: 2;
        }
        
        textarea:focus {
            outline: none;
            border-color: #0066cc;
        }
        
        .preview-panel {
            position: fixed !important;
            top: 20px !important;
            right: 20px !important;
            width: 320px !important;
            height: auto !important;
            z-index: 9999 !important;
            background: transparent !important;
        }
        
        .preview-container {
            background: #2d2d2d;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 10px;
            position: relative;
        }
        
        .pip-canvas {
            width: 100%;
            height: auto;
            border-radius: 4px;
            background: #000;
        }

        .progress-bars {
            margin-top: 10px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .frame-controls {
            display: flex;
            align-items: center;
            gap: 1px;
            margin: 2px 0;
        }

        .frame-btn {
            background: #333;
            color: #ccc;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 3px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            transition: background 0.2s;
        }

        .frame-btn:hover {
            background: #444;
            color: #fff;
        }

        .frame-btn:disabled {
            background: #222;
            color: #555;
            cursor: not-allowed;
        }

        .pause-btn {
            width: 28px !important;
            font-size: 12px !important;
            margin-left: 2px;
        }

        #frameSlider {
            flex: 1;
            height: 4px;
            background: #1a1a1a;
            border-radius: 2px;
            outline: none;
            -webkit-appearance: none;
        }

        #frameSlider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #00cc66;
            cursor: pointer;
            border: 2px solid #1a1a1a;
        }

        #frameSlider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: #00cc66;
            cursor: pointer;
            border: 2px solid #1a1a1a;
        }

        .frame-counter {
            font-size: 10px;
            color: #ccc;
            min-width: 45px;
            text-align: center;
            font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
        }

        .progress-container {
            position: relative;
            width: 100%;
            height: 6px;
            background: #1a1a1a;
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            border-radius: 3px;
            transition: width 0.1s ease;
        }

        .loop-progress {
            background: linear-gradient(90deg, #00cc66, #66ff99);
        }

        .export-progress {
            background: linear-gradient(90deg, #0066cc, #3399ff);
        }

        .progress-label {
            font-size: 10px;
            color: #ccc;
            margin-bottom: 3px;
        }
        
        .error-display {
            background: #4a1a1a;
            border: 1px solid #aa3333;
            border-radius: 4px;
            padding: 10px;
            margin-top: 10px;
            font-size: 12px;
            color: #ff9999;
            white-space: pre-wrap;
            display: none;
        }
        
        h1 {
            margin: 0 0 20px 0;
            color: #0066cc;
            font-size: 24px;
        }
        
        .info {
            background: #2d2d2d;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 20px;
            font-size: 14px;
            line-height: 1.5;
        }
        
        .info h3 {
            margin: 0 0 10px 0;
            color: #00cc66;
        }
        
        .preset-buttons {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }
        
        .preset-btn {
            background: #333;
            color: #ccc;
            font-size: 12px;
            padding: 6px 12px;
        }
        
        .preset-btn:hover {
            background: #444;
        }
		
		.size-controls {
			margin-top: 10px;
			padding-top: 10px;
			border-top: 1px solid #444;
		}

		.size-controls > div:first-child {
			display: flex;
			gap: 6px;
			justify-content: center;
			margin-bottom: 8px;
		}

		.size-btn {
			background: #333;
			color: #ccc;
			border: none;
			padding: 4px 8px;
			border-radius: 3px;
			cursor: pointer;
			font-family: inherit;
			font-size: 10px;
			transition: background 0.2s;
		}

		.size-btn:hover {
			background: #444;
			color: #fff;
		}

		.size-btn.active {
			background: #0066cc;
			color: white;
		}

		.size-slider-container {
			display: flex;
			align-items: center;
			gap: 8px;
			justify-content: center;
		}

		.size-slider {
			width: 100px;
			height: 4px;
			background: #1a1a1a;
			border-radius: 2px;
			outline: none;
			-webkit-appearance: none;
		}

		.size-slider::-webkit-slider-thumb {
			-webkit-appearance: none;
			appearance: none;
			width: 12px;
			height: 12px;
			border-radius: 50%;
			background: #0066cc;
			cursor: pointer;
			border: 2px solid #1a1a1a;
		}

		.size-slider::-moz-range-thumb {
			width: 12px;
			height: 12px;
			border-radius: 50%;
			background: #0066cc;
			cursor: pointer;
			border: 2px solid #1a1a1a;
		}

		.size-input {
			background: #1a1a1a;
			border: 1px solid #555;
			border-radius: 3px;
			color: #fff;
			padding: 3px 6px;
			width: 50px;
			font-size: 10px;
			font-family: inherit;
			text-align: center;
		}

		.size-input:focus {
			outline: none;
			border-color: #0066cc;
		}

		.size-label {
			font-size: 10px;
			color: #ccc;
			font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
		}
		
    </style>
</head>
<body>
    <div class="editor-panel">
        <h1>p5.js Spiral Editor</h1>
        

        
        <div class="preset-buttons">
            <button class="preset-btn" onclick="loadPreset('spiral')">Hypnotic Spiral</button>
            <button class="preset-btn" onclick="loadPreset('waves')">Wave Pattern</button>
            <button class="preset-btn" onclick="loadPreset('tunnel')">Tunnel Effect</button>
            <button class="preset-btn" onclick="loadPreset('mandala')">Rotating Mandala</button>
            <button class="preset-btn" onclick="loadPreset('plasma')">Plasma Field</button>
        </div>
        
        <textarea id="codeEditor" spellcheck="false"></textarea>
        <div id="errorDisplay" class="error-display"></div>
		<div id="canvasContainer"></div>
    </div>
    
    <div class="preview-panel">
        <div class="preview-container">
			<div class="controls">
				<button onclick="runWithoutLag()">Run</button>
				<button onclick="stopAnimation()">Stop</button>
				<button onclick="clearCode()">Clear</button>
				<span id="status" style="color: #00cc66;"></span>
			</div>
			
			<div class="export-controls">
				<button onclick="exportGif()" id="exportGifBtn" disabled>Export GIF</button>
				<button onclick="exportWebP()" id="exportWebPBtn" disabled>Export WebP</button>
				<button onclick="exportMP4()" id="exportMP4Btn" disabled>Export MP4</button>
				<span id="exportStatus" style="margin-left: 10px; color: #ffaa00; font-size: 12px;"></span>
			</div>
			
			<div class="animation-controls">
				<div class="control-group">
					<label for="framesInput">Frames:</label>
					<input type="number" id="framesInput" value="120" min="10" max="1000" onchange="updateAnimationSettings()">
				</div>
				<div class="control-group">
					<label for="fpsInput">FPS:</label>
					<input type="number" id="fpsInput" value="60" min="1" max="120" onchange="updateAnimationSettings()">
				</div>
				
				<div class="control-group">
					<label for="speedInput">Speed:</label>
					<input type="number" id="speedInput" value="1" min="0.1" max="5" step="0.1" onchange="updateAnimationSettings()">
				</div>
			</div>
            <div class="progress-bars">
                <div class="frame-controls">
                    <button class="frame-btn" id="prevFrameBtn" onclick="previousFrame()">‹</button>
                    <input type="range" id="frameSlider" min="0" max="120" value="0" oninput="scrubToFrame(this.value)">
                    <button class="frame-btn" id="nextFrameBtn" onclick="nextFrame()">›</button>
                    <button class="frame-btn pause-btn" id="pauseFrameBtn" onclick="pauseAnimation()" disabled>⏸</button>
                    <span id="frameDisplay" class="frame-counter">000/120</span>
                </div>
                <div>
                    <div class="progress-label">Export Progress</div>
                    <div class="progress-container">
                        <div class="progress-bar export-progress" id="exportProgressBar" style="width: 0%"></div>
                    </div>
                </div>
				<div class="size-controls">
                <div style="margin-bottom: 8px;">
                    <button class="size-btn active" onclick="setCanvasRatio('1:1')">Square (1:1)</button>
                    <button class="size-btn" onclick="setCanvasRatio('4:3')">Desktop (4:3)</button>
                    <button class="size-btn" onclick="setCanvasRatio('3:4')">Phone (3:4)</button>
                </div>
                <div class="size-slider-container">
                    <input type="range" class="size-slider" id="sizeSlider" min="300" max="1000" value="300" oninput="updateCanvasSize(this.value)">
                    <input type="number" class="size-input" id="sizeInput" min="300" max="1000" value="300" onchange="updateCanvasSizeFromInput(this.value)">
                    <span class="size-label">px</span>
                </div>
            </div>
            </div>
        </div>
    </div>

    <script>
        let currentSketch = null;
        let isRunning = false;
        let isPaused = false;
        let loopFrameCount = 0;
        let framesPerLoop = 360;
        let animationFPS = 60;
        let animationSpeed = 1;
        let lastFrameTime = 0;
        let virtualFrameCount = 0;
		let canvasRatio = '1:1'; // '1:1', '4:3', or '3:4'
		let baseSize = 300;
		let canvasWidth = 300;
		let canvasHeight = 300;
		let animationLoopId = null;

        const presets = {
			tunnel: `function setup() {
  createCanvas(300, 300);
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0);
  translate(width/2, height/2);
  
  // Create perfect loop by using frameCount with TWO_PI
  let time = (frameCount / 120) * TWO_PI; // Complete one cycle per loop
  
  for (let i = 0; i < 50; i++) {
    let size = 300 - i * 6 + sin(time + i * 0.2) * 20;
    let hue = (i * 10 + (frameCount * 2)) % 360;
    
    stroke(hue, 80, 90);
    strokeWeight(2);
    noFill();
    
    ellipse(0, 0, size*2, size*2);
  }
}`,

            spiral: `function setup() {
  createCanvas(300, 300);
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 10);
  translate(width/2, height/2);
  
  // Perfect loop: complete one cycle per animation loop
  let time = (frameCount / 120) * TWO_PI * 0.4; // 0.4 for slower rotation
  
  for (let i = 0; i < 200; i++) {
    let angle = i * 0.1 + time;
    let radius = i * 0.8;
    
    let x = cos(angle) * radius;
    let y = sin(angle) * radius;
    
    let hue = (i * 2 + frameCount * 3) % 360;
    fill(hue, 80, 90, 0.8);
    noStroke();
    
    ellipse(x, y, 8, 8);
  }
}`,

            waves: `function setup() {
  createCanvas(300, 300);
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 5);
  
  // Perfect loop timing
  let time = (frameCount / 120) * TWO_PI * 0.6; // Complete cycles per loop
  
  for (let y = 0; y < height; y += 4) {
    for (let x = 0; x < width; x += 4) {
      let d = dist(x, y, width/2, height/2);
      let wave = sin(d * 0.05 - time * 5) * 50;
      
      let hue = (d + frameCount * 2) % 360;
      let brightness = map(wave, -50, 50, 30, 100);
      
      fill(hue, 70, brightness);
      noStroke();
      rect(x, y, 4, 4);
    }
  }
}`,

            mandala: `function setup() {
  createCanvas(300, 300);
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  background(0, 0, 10);
  translate(width/2, height/2);
  
  // Perfect loop rotation
  let time = (frameCount / 120) * TWO_PI * 0.1; // One complete rotation per loop
  
  for (let layer = 0; layer < 8; layer++) {
    rotate(time * (layer + 1));
    
    for (let i = 0; i < 12; i++) {
      let angle = (TWO_PI / 12) * i;
      let radius = 30 + layer * 20;
      
      let x = cos(angle) * radius;
      let y = sin(angle) * radius;
      
      let hue = (layer * 45 + i * 10 + frameCount) % 360;
      fill(hue, 70, 80);
      noStroke();
      
      ellipse(x, y, 8 - layer, 8 - layer);
    }
  }
}`,

            plasma: `function setup() {
  createCanvas(300, 300);
  colorMode(HSB, 360, 100, 100);
}

function draw() {
  // Perfect loop timing for all wave components
  let time = (frameCount / 120) * TWO_PI;
  
  for (let x = 0; x < width; x += 2) {
    for (let y = 0; y < height; y += 2) {
      let plasma = sin(x * 0.02 + time) + 
                   sin(y * 0.03 + time * 1.3) + 
                   sin((x + y) * 0.01 + time * 0.8) +
                   sin(sqrt(x*x + y*y) * 0.02 + time * 2);
      
      let hue = map(plasma, -4, 4, 0, 360);
      let brightness = map(sin(plasma + time), -1, 1, 30, 100);
      
      fill(hue, 80, brightness);
      noStroke();
      rect(x, y, 2, 2);
    }
  }
}`
        };
		
		function runWithoutLag() {
			stopAnimation();
				setTimeout(() => {
					runAnimation();
				}, 100);
		}
		
		function setCanvasRatio(ratio) {
			canvasRatio = ratio;
			
			// Update button states
			document.querySelectorAll('.size-btn').forEach(btn => btn.classList.remove('active'));
			event.target.classList.add('active');
			
			// Recalculate dimensions with current base size
			updateCanvasSize(baseSize);
		}
		
		function updateCanvasSize(size) {
			baseSize = parseInt(size);
			document.getElementById('sizeSlider').value = baseSize;
			document.getElementById('sizeInput').value = baseSize;
			
			// Calculate dimensions based on ratio
			switch(canvasRatio) {
				case '1:1':
					canvasWidth = baseSize;
					canvasHeight = baseSize;
					break;
				case '4:3':
					canvasWidth = baseSize;
					canvasHeight = Math.round(baseSize * 3 / 4);
					break;
				case '3:4':
					canvasWidth = Math.round(baseSize * 3 / 4);
					canvasHeight = baseSize;
					break;
			}
			
			// Update all preset codes to use dynamic canvas size
			updatePresetCanvasSizes();
			
			// Restart animation with new size if currently running
			if (isRunning) {
				runAnimation();
			}
			
			stopAnimation();
			setTimeout(() => {
				runAnimation();
			}, 100);
		}
		
		function updateCanvasSizeFromInput(size) {
			const sizeValue = parseInt(size);
			if (sizeValue >= 300 && sizeValue <= 1000) {
				document.getElementById('sizeSlider').value = sizeValue;
				updateCanvasSize(sizeValue);
			} else {
				// Reset input to current valid value
				document.getElementById('sizeInput').value = baseSize;
			}
		}
		
		function updatePresetCanvasSizes() {
			// Update all presets to use current canvas dimensions
			Object.keys(presets).forEach(key => {
				presets[key] = presets[key].replace(/createCanvas\(\d+,\s*\d+\)/, `createCanvas(${canvasWidth}, ${canvasHeight})`);
			});
			
			// Update current code in editor if it contains createCanvas
			const currentCode = document.getElementById('codeEditor').value;
			if (currentCode.includes('createCanvas(')) {
				const updatedCode = currentCode.replace(/createCanvas\(\d+,\s*\d+\)/, `createCanvas(${canvasWidth}, ${canvasHeight})`);
				document.getElementById('codeEditor').value = updatedCode;
			}
		}


        function updateLoopProgress() {
			if (!isRunning || isPaused) return;
			
			const currentTime = Date.now();
			const frameInterval = 1000 / (animationFPS * animationSpeed);
			
			if (currentTime - lastFrameTime >= frameInterval) {
				virtualFrameCount++;
				lastFrameTime = currentTime;
				
				if (virtualFrameCount >= framesPerLoop) {
					virtualFrameCount = 0;
				}
				
				loopFrameCount = virtualFrameCount;
				updateUI();
			}
			
			animationLoopId = requestAnimationFrame(updateLoopProgress);
		}

        function updateUI() {
            document.getElementById('frameSlider').value = loopFrameCount;
            // Format frame numbers with leading zeros to maintain consistent width
            const currentFrameStr = String(loopFrameCount).padStart(3, '0');
            const totalFrameStr = String(framesPerLoop).padStart(3, '0');
            document.getElementById('frameDisplay').textContent = `${currentFrameStr}/${totalFrameStr}`;
            
            // Trigger a redraw if animation is loaded
            if (currentSketch && typeof draw === 'function') {
                draw();
            }
        }

        function scrubToFrame(frameNum) {
            frameNum = parseInt(frameNum);
            if (frameNum >= 0 && frameNum < framesPerLoop) {
                virtualFrameCount = frameNum;
                loopFrameCount = frameNum;
                updateUI();
            }
        }

        function nextFrame() {
            if (virtualFrameCount < framesPerLoop - 1) {
                virtualFrameCount++;
            } else {
                virtualFrameCount = 0; // Loop back to start
            }
            loopFrameCount = virtualFrameCount;
            updateUI();
        }

        function previousFrame() {
            if (virtualFrameCount > 0) {
                virtualFrameCount--;
            } else {
                virtualFrameCount = framesPerLoop - 1; // Loop to end
            }
            loopFrameCount = virtualFrameCount;
            updateUI();
        }

        function updateExportProgress(percentage) {
            document.getElementById('exportProgressBar').style.width = percentage + '%';
        }

        function updateAnimationSettings() {
            const oldFramesPerLoop = framesPerLoop;
            framesPerLoop = parseInt(document.getElementById('framesInput').value) || 120;
            animationFPS = parseInt(document.getElementById('fpsInput').value) || 60;
            animationSpeed = parseFloat(document.getElementById('speedInput').value) || 1;
            
            // Update slider max value
            document.getElementById('frameSlider').max = framesPerLoop - 1;
            
            // Adjust current frame if frames per loop changed
            if (virtualFrameCount >= framesPerLoop) {
                virtualFrameCount = framesPerLoop - 1;
                loopFrameCount = virtualFrameCount;
            }
            
            lastFrameTime = Date.now();
            updateUI();
        }

        function loadPreset(name) {
            document.getElementById('codeEditor').value = presets[name];
        }

        function runAnimation() {
            if (currentSketch) {
                currentSketch.remove();
            }

            const code = document.getElementById('codeEditor').value;
            const errorDisplay = document.getElementById('errorDisplay');
            const status = document.getElementById('status');
            
            errorDisplay.style.display = 'none';
            virtualFrameCount = 0;
            loopFrameCount = 0;
            isPaused = false;
            lastFrameTime = Date.now();
            
            // Update slider
            document.getElementById('frameSlider').max = framesPerLoop - 1;
            
            try {
                // Create a new p5 sketch with proper instance mode
                const sketch = function(p) {
                    // Make p5 functions available globally within this scope
                    const originalFunctions = {};
                    const p5Functions = ['createCanvas', 'background', 'fill', 'stroke', 'noStroke', 'noFill', 
                                        'ellipse', 'rect', 'line', 'point', 'triangle', 'quad', 'arc',
                                        'translate', 'rotate', 'scale', 'push', 'pop', 'frameCount',
                                        'width', 'height', 'mouseX', 'mouseY', 'sin', 'cos', 'tan',
                                        'map', 'lerp', 'dist', 'random', 'noise', 'TWO_PI', 'PI', 'HALF_PI',
                                        'colorMode', 'HSB', 'RGB', 'strokeWeight', 'textSize', 'text',
                                        'sqrt', 'pow', 'abs', 'floor', 'ceil', 'round', 'radians', 'degrees'];
                    
                    // Expose p5 functions and properties to global scope
                    p5Functions.forEach(func => {
                        if (typeof p[func] !== 'undefined') {
                            window[func] = p[func].bind ? p[func].bind(p) : p[func];
                        }
                    });
                    
                    // Special handling for properties - override frameCount with our controlled version
                    Object.defineProperty(window, 'frameCount', { get: () => virtualFrameCount });
                    Object.defineProperty(window, 'width', { get: () => p.width });
                    Object.defineProperty(window, 'height', { get: () => p.height });
                    Object.defineProperty(window, 'mouseX', { get: () => p.mouseX });
                    Object.defineProperty(window, 'mouseY', { get: () => p.mouseY });
                    
                    // Execute user code
                    try {
                        eval(code);
                    } catch (e) {
                        throw new Error('Code execution error: ' + e.message);
                    }
                    
					p.setup = function() {
						const canvas = p.createCanvas(canvasWidth, canvasHeight);
						canvas.parent('canvasContainer');
						p.frameRate(framesPerLoop);
						if (typeof setup === 'function') {
							setup();
						}
					};
                    
                    p.draw = function() {
                        // Only draw when our virtual frame timing allows it
                        const shouldDraw = Date.now() - lastFrameTime >= (1000 / (animationFPS * animationSpeed));
                        if (shouldDraw && typeof draw === 'function') {
                            draw();
                        }
                    };
                };

                currentSketch = new p5(sketch);
                isRunning = true;
                status.textContent = 'Running...';
                status.style.color = '#00cc66';
                
                // Start loop progress animation
                updateLoopProgress();
                
                // Enable export buttons and frame controls
                document.getElementById('exportGifBtn').disabled = false;
                document.getElementById('exportWebPBtn').disabled = false;
                document.getElementById('exportMP4Btn').disabled = false;
                document.getElementById('pauseFrameBtn').disabled = false;
                document.getElementById('prevFrameBtn').disabled = false;
                document.getElementById('nextFrameBtn').disabled = false;
                document.getElementById('frameSlider').disabled = false;
                
            } catch (error) {
                errorDisplay.textContent = 'Error: ' + error.message;
                errorDisplay.style.display = 'block';
                status.textContent = 'Error';
                status.style.color = '#ff6666';
            }
        }

        function pauseAnimation() {
            if (!isRunning) return;
            
            isPaused = !isPaused;
            const pauseBtn = document.getElementById('pauseFrameBtn');
            const status = document.getElementById('status');
            
            if (isPaused) {
                pauseBtn.textContent = '▶';
                status.textContent = 'Paused';
                status.style.color = '#ffaa00';
            } else {
                pauseBtn.textContent = '⏸';
                status.textContent = 'Running...';
                status.style.color = '#00cc66';
                lastFrameTime = Date.now();
            }
        }

        function stopAnimation() {
			if (animationLoopId) {
				cancelAnimationFrame(animationLoopId);
				animationLoopId = null;
			}
	
            if (currentSketch) {
				currentSketch.remove();
				currentSketch = null;
			}
			isRunning = false;
			isPaused = false;
			
			// Clear global p5 function references
			const p5Functions = ['createCanvas', 'background', 'fill', 'stroke', 'noStroke', 'noFill', 
								'ellipse', 'rect', 'line', 'point', 'triangle', 'quad', 'arc',
								'translate', 'rotate', 'scale', 'push', 'pop',
								'width', 'height', 'mouseX', 'mouseY', 'sin', 'cos', 'tan',
								'map', 'lerp', 'dist', 'random', 'noise', 'TWO_PI', 'PI', 'HALF_PI',
								'colorMode', 'HSB', 'RGB', 'strokeWeight', 'textSize', 'text',
								'sqrt', 'pow', 'abs', 'floor', 'ceil', 'round', 'radians', 'degrees'];
			
			p5Functions.forEach(func => {
				if (window[func]) {
					delete window[func];
				}
			});
			
			// Clean up global functions
			if (window.setup) delete window.setup;
			if (window.draw) delete window.draw;
			
            document.getElementById('status').textContent = 'Stopped';
            document.getElementById('status').style.color = '#ffaa00';
            
            // Reset export progress bar and frame display
            document.getElementById('exportProgressBar').style.width = '0%';
            document.getElementById('frameSlider').value = 0;
            document.getElementById('frameDisplay').textContent = '000/120';
            
            // Disable export buttons and frame controls
            document.getElementById('exportGifBtn').disabled = true;
            document.getElementById('exportWebPBtn').disabled = true;
            document.getElementById('exportMP4Btn').disabled = true;
            document.getElementById('pauseFrameBtn').disabled = true;
            document.getElementById('pauseFrameBtn').textContent = '⏸';
            document.getElementById('prevFrameBtn').disabled = true;
            document.getElementById('nextFrameBtn').disabled = true;
            document.getElementById('frameSlider').disabled = true;
        }

        function clearCode() {
            document.getElementById('codeEditor').value = '';
            stopAnimation();
        }

        // Export functions
        let capturedFrames = [];
        let isCapturing = false;

        function captureFrames(duration = 3000, callback) {
            if (!currentSketch || !isRunning) {
                document.getElementById('exportStatus').textContent = 'No animation running';
                return;
            }

            capturedFrames = [];
            isCapturing = true;
            const startTime = Date.now();
            const targetFrames = 60; // Capture 60 frames for ~2 second loop
            const frameInterval = duration / targetFrames;

            document.getElementById('exportStatus').textContent = 'Capturing frames...';
            updateExportProgress(0);

            const captureFrame = () => {
                if (capturedFrames.length >= targetFrames || Date.now() - startTime > duration) {
                    isCapturing = false;
                    updateExportProgress(100);
                    callback();
                    return;
                }

                const canvas = document.querySelector('#canvasContainer canvas');
                if (canvas) {
                    capturedFrames.push(canvas.toDataURL('image/png'));
                }

                // Update export progress
                const progress = (capturedFrames.length / targetFrames) * 100;
                updateExportProgress(progress);

                setTimeout(captureFrame, frameInterval);
            };

            captureFrame();
        }

         function exportGif() {
            if (!currentSketch || !isRunning) {
                document.getElementById('exportStatus').textContent = 'No animation running';
                return;
            }

            // Since gif.js isn't available, export as WebM video instead
            document.getElementById('exportStatus').textContent = 'Exporting as WebM video (GIF alternative)...';
            exportWebM();
        }

        function exportWebM() {
            const canvas = document.querySelector('#canvasContainer canvas') || 
                          document.querySelector('canvas') || 
                          (currentSketch && currentSketch.canvas);
            
            if (!canvas) {
                document.getElementById('exportStatus').textContent = 'Canvas not found';
                return;
            }

            // Check if MediaRecorder is supported
            if (!MediaRecorder.isTypeSupported('video/webm')) {
                // Fallback: capture individual frames as images
                exportFrameSequence();
                return;
            }

            const stream = canvas.captureStream(animationFPS);
            const recorder = new MediaRecorder(stream, {
                mimeType: 'video/webm;codecs=vp8',
                videoBitsPerSecond: 2500000
            });
            
            const chunks = [];
            
            recorder.ondataavailable = (e) => {
                if (e.data.size > 0) {
                    chunks.push(e.data);
                }
            };
            
            recorder.onstop = () => {
                const blob = new Blob(chunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.download = `animation_${framesPerLoop}frames_${Date.now()}.webm`;
                link.href = url;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(url);
                
                document.getElementById('exportStatus').textContent = 'WebM video exported (can be converted to GIF with online tools)';
                updateExportProgress(100);
                
                setTimeout(() => {
                    updateExportProgress(0);
                    document.getElementById('exportStatus').textContent = '';
                }, 3000);
            };
            
            // Store current state
            const originalFrameCount = virtualFrameCount;
            const wasRunning = !isPaused;
            
            // Start from beginning for clean recording
            virtualFrameCount = 0;
            loopFrameCount = 0;
            updateUI();
            
            if (isPaused) {
                isPaused = false;
                lastFrameTime = Date.now();
            }
            
            // Record for the duration of one complete loop plus a bit extra
            const recordDuration = (framesPerLoop / animationFPS) * 1000 + 200;
            
            recorder.start();
            updateExportProgress(25);
            
            setTimeout(() => {
                updateExportProgress(75);
            }, recordDuration / 2);
            
            setTimeout(() => {
                recorder.stop();
                updateExportProgress(90);
                
                // Restore original state
                virtualFrameCount = originalFrameCount;
                loopFrameCount = originalFrameCount;
                if (!wasRunning) {
                    isPaused = true;
                }
                updateUI();
            }, recordDuration);
        }

        function exportFrameSequence() {
            document.getElementById('exportStatus').textContent = 'Exporting frame sequence...';
            
            const canvas = document.querySelector('#canvasContainer canvas') || 
                          document.querySelector('canvas') || 
                          (currentSketch && currentSketch.canvas);
                          
            if (!canvas) {
                document.getElementById('exportStatus').textContent = 'Canvas not found';
                return;
            }
            
            // Store current state
            const originalFrameCount = virtualFrameCount;
            const wasRunning = !isPaused;
            if (wasRunning) isPaused = true;
            
            const frames = [];
            let currentFrame = 0;
            
            const captureNextFrame = () => {
                if (currentFrame >= Math.min(framesPerLoop, 60)) { // Limit to 60 frames max
                    createZipFromFrames(frames);
                    
                    // Restore state
                    virtualFrameCount = originalFrameCount;
                    loopFrameCount = originalFrameCount;
                    if (wasRunning) {
                        isPaused = false;
                        lastFrameTime = Date.now();
                    }
                    updateUI();
                    return;
                }
                
                virtualFrameCount = currentFrame;
                loopFrameCount = currentFrame;
                updateUI();
                
                setTimeout(() => {
                    const dataURL = canvas.toDataURL('image/png');
                    frames.push({
                        name: `frame_${String(currentFrame).padStart(3, '0')}.png`,
                        data: dataURL
                    });
                    
                    const progress = (currentFrame / Math.min(framesPerLoop, 60)) * 90;
                    updateExportProgress(progress);
                    
                    currentFrame++;
                    setTimeout(captureNextFrame, 100);
                }, 100);
            };
            
            captureNextFrame();
        }

        function createZipFromFrames(frames) {
            // Since we can't create a ZIP easily in browser without libraries,
            // just download the first frame as a sample
            if (frames.length > 0) {
                const link = document.createElement('a');
                link.download = 'animation_sample_frame.png';
                link.href = frames[0].data;
                link.click();
                
                document.getElementById('exportStatus').textContent = `Sample frame exported (${frames.length} frames captured)`;
                updateExportProgress(100);
                
                setTimeout(() => {
                    updateExportProgress(0);
                    document.getElementById('exportStatus').textContent = '';
                }, 3000);
            }
        }
		
		function createAnimatedGif() {
			if (capturedFrames.length === 0) {
				document.getElementById('exportStatus').textContent = 'No frames captured';
				updateExportProgress(0);
				return;
			}

			document.getElementById('exportStatus').textContent = 'Creating animated GIF...';
			updateExportProgress(80);

			try {
				// Initialize GIF.js with better settings
				const gif = new GIF({
					workers: 1, // Reduce workers to avoid issues
					quality: 15, // Slightly higher quality number (lower quality but more stable)
					width: 300,
					height: 300,
					repeat: 0, // Loop forever
					debug: true, // Enable debug mode
					transparent: null
				});

				// Add error handler
				gif.on('error', function(error) {
					console.error('GIF creation error:', error);
					document.getElementById('exportStatus').textContent = 'GIF creation failed: ' + error.message;
					updateExportProgress(0);
				});

				// Add all captured frames with proper delay
				const delay = Math.round(1000 / animationFPS);
				capturedFrames.forEach((canvas, index) => {
					try {
						gif.addFrame(canvas, {delay: delay, copy: true});
						const progress = 80 + (index / capturedFrames.length) * 10;
						updateExportProgress(progress);
					} catch (frameError) {
						console.error('Error adding frame:', frameError);
					}
				});

				gif.on('finished', function(blob) {
					updateExportProgress(100);
					
					// Create download link
					const url = URL.createObjectURL(blob);
					const link = document.createElement('a');
					link.download = `animation_${framesPerLoop}frames_${Date.now()}.gif`;
					link.href = url;
					document.body.appendChild(link);
					link.click();
					document.body.removeChild(link);
					URL.revokeObjectURL(url);
					
					document.getElementById('exportStatus').textContent = `Animated GIF exported (${capturedFrames.length} frames)`;
					
					setTimeout(() => {
						updateExportProgress(0);
						document.getElementById('exportStatus').textContent = '';
					}, 3000);
				});

				gif.on('progress', function(p) {
					console.log('GIF progress:', p);
					const progress = 90 + (p * 10);
					updateExportProgress(progress);
				});

				// Add timeout to prevent infinite hang
				setTimeout(() => {
					if (document.getElementById('exportStatus').textContent.includes('Creating')) {
						document.getElementById('exportStatus').textContent = 'GIF creation timed out - try fewer frames';
						updateExportProgress(0);
					}
				}, 30000); // 30 second timeout

				gif.render();
				
			} catch (error) {
				console.error('GIF initialization error:', error);
				document.getElementById('exportStatus').textContent = 'Failed to initialize GIF creator';
				updateExportProgress(0);
			}
		}

        function exportWebP() {
			document.getElementById('exportStatus').textContent = 'WebP animation via screen recording...';
			
			const canvas = document.querySelector('#canvasContainer canvas') || 
						  document.querySelector('canvas') || 
						  (currentSketch && currentSketch.canvas);
			
			if (!canvas) {
				document.getElementById('exportStatus').textContent = 'Canvas not found';
				return;
			}

			const stream = canvas.captureStream(animationFPS);
			const recorder = new MediaRecorder(stream, {
				mimeType: 'video/webm;codecs=vp9'
			});
			
			const chunks = [];
			
			recorder.ondataavailable = (e) => {
				if (e.data.size > 0) {
					chunks.push(e.data);
				}
			};
			
			recorder.onstop = () => {
				const blob = new Blob(chunks, { type: 'video/webm' });
				const url = URL.createObjectURL(blob);
				const link = document.createElement('a');
				link.download = `animation_${Date.now()}.webm`;
				link.href = url;
				document.body.appendChild(link);
				link.click();
				document.body.removeChild(link);
				URL.revokeObjectURL(url);
				
				document.getElementById('exportStatus').textContent = 'WebM video exported (similar quality to animated WebP)';
				updateExportProgress(100);
				
				setTimeout(() => {
					updateExportProgress(0);
					document.getElementById('exportStatus').textContent = '';
				}, 3000);
			};
			
			// Record for the duration of one complete loop
			const recordDuration = (framesPerLoop / animationFPS) * 1000;
			
			recorder.start();
			updateExportProgress(50);
			
			setTimeout(() => {
				recorder.stop();
				updateExportProgress(90);
			}, recordDuration);
		}

        function exportMP4() {
            document.getElementById('exportStatus').textContent = 'MP4 export not available in browser (requires server-side processing)';
            
            // Simulate some progress for visual feedback
            let progress = 0;
            const interval = setInterval(() => {
                progress += 20;
                updateExportProgress(progress);
                if (progress >= 100) {
                    clearInterval(interval);
                    setTimeout(() => {
                        const canvas = document.querySelector('#canvasContainer canvas') || 
							   document.querySelector('canvas') || 
							   (currentSketch && currentSketch.canvas);
                        if (canvas) {
                            const link = document.createElement('a');
                            link.download = 'animation_frame.png';
                            link.href = canvas.toDataURL('image/png');
                            link.click();
                            document.getElementById('exportStatus').textContent = 'Frame saved as PNG (MP4 requires external tools)';
                            setTimeout(() => updateExportProgress(0), 2000);
                        }
                    }, 500);
                }
            }, 200);
        }

        // Load default spiral preset
        window.onload = function() {
			loadPreset('tunnel');
			updateCanvasSize(300); // Initialize with default size
			
			// Auto-run when user stops typing for 1 second
			let timeout;
			document.getElementById('codeEditor').addEventListener('input', function() {
				clearTimeout(timeout);
				timeout = setTimeout(() => {
					if (isRunning) {
						stopAnimation();
						setTimeout(() => {
							runAnimation();
						}, 100);
					}
				}, 1000);
			});
		};

        // Handle tab key in textarea
        document.getElementById('codeEditor').addEventListener('keydown', function(e) {
            if (e.key === 'Tab') {
                e.preventDefault();
                const start = this.selectionStart;
                const end = this.selectionEnd;
                this.value = this.value.substring(0, start) + '  ' + this.value.substring(end);
                this.selectionStart = this.selectionEnd = start + 2;
            }
        });
    </script>
</body>
</html>